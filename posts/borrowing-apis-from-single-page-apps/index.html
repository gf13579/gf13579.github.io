<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Connecting the Unconnectable; Borrowing APIs from Single Page Applications | spinning plates</title><meta name=keywords content><meta name=description content="A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data."><meta name=author content><link rel=canonical href=https://spinningplates.net/posts/borrowing-apis-from-single-page-apps/><link crossorigin=anonymous href=/assets/css/stylesheet.faeb00df757dc3b73e8e251d8461633d065be58338a3336b4a81564cefcf240f.css integrity="sha256-+usA33V9w7c+jiUdhGFjPQZb5YM4ozNrSoFWTO/PJA8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://spinningplates.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://spinningplates.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://spinningplates.net/favicon-32x32.png><link rel=apple-touch-icon href=https://spinningplates.net/apple-touch-icon.png><link rel=mask-icon href=https://spinningplates.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Connecting the Unconnectable; Borrowing APIs from Single Page Applications"><meta property="og:description" content="A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data."><meta property="og:type" content="article"><meta property="og:url" content="https://spinningplates.net/posts/borrowing-apis-from-single-page-apps/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-02T00:49:16+10:00"><meta property="article:modified_time" content="2022-12-02T00:49:16+10:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Connecting the Unconnectable; Borrowing APIs from Single Page Applications"><meta name=twitter:description content="A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://spinningplates.net/posts/"},{"@type":"ListItem","position":2,"name":"Connecting the Unconnectable; Borrowing APIs from Single Page Applications","item":"https://spinningplates.net/posts/borrowing-apis-from-single-page-apps/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Connecting the Unconnectable; Borrowing APIs from Single Page Applications","name":"Connecting the Unconnectable; Borrowing APIs from Single Page Applications","description":"A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data.","keywords":[],"articleBody":"A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data.\nSome products make this easy - cloud-managed solutions might provide an API to poll for new alerts, on-prem products might write events to an event log or log file. Others might let you configure them to send an email or contact a webhook to notify you about a detection.\nSome products make this much harder than it should be. In this post we’ll look at Check Point Harmony (CPH), which presents the following challenges:\nAn API that doesn’t currently support polling for EDR detections Email notifications that can’t be used to alert on every detection as they have thresholds that can’t be set lower than 2 A syslog-over-the-internet approach, recommended by Check Point, but apparently not relevant if an organisation has no on-prem management servers The Query Process What CPH does let you do is view detections (‘active attacks’) through its Infinity Portal web site - here we see the Threat Hunting tab list 2 ‘active attacks’ i.e. open alerts based on detections:\nDrilling down on those 2 alerts:\nModern websites commonly use a Single Page Application approach where client-side JavaScript code is used to access backend APIs as a user interacts with the web application, avoiding the need for full page refreshes and (usually) resulting in better interactive experience for the user.\nIf we hit F12 to open the browser’s dev tools, open the Network tab and refresh the page, we can watch for Fetch/XmlHttpRequest requests made when the page loads. Searching all content for a distinctive value shown on the web page (e.g. nvio.x64.exe) we see a response from prod-gcp-apollo/ that returns JSON data containing full details of the detection - to be rendered client-side:\nThe payload in the request that generated this content shows that a query string was submitted, along with parameters controlling date ranges, result order and pagination:\nSo now we know we know which endpoint (prod-gcp-apollo/) to query, the method (POST), the body of the request, and what the response looks like.\nAll that remains is to analyse the authentication process, then recreate the two steps (authenticate, query) in a scheduled script that outputs the results to our SIEM.\nAuthentication Let’s apply the same process to analyse authentication. Check Point provides options to manage API keys, however, the API doesn’t yet support what we’re trying to query. We’ll need to use a user account acting as a service account (ideally with least privileges and a complex password).\nWhen we browse to https://ap.portal.checkpoint.com/signin we’re prompted for a username, then a password. The Network tab shows a POST against /auth/user:\nWe can see the server response included a directive to set a cloudinfra cookie - a signed JWT - containing assertions about our identity and permissions:\nIn addition, towards the end of the response we see a value called csrf - a Cross Site Request Forgery (CSRF) token with an expiry of 900 seconds (15 minutes):\nThe browser will automatically include our cookie in subsequent requests to the same origin (https://ap.portal.checkpoint.com). It’s likely the server will also expect the CSRF token to be included and will validate that the token corresponds to our session - and potentially the code submitting the request.\nLooking at subsequent requests - including the one to retrieve active attacks, we see the same CSRF token appear as a custom HTTP header in the request:\nWe now know how to authenticate with a username and password, and how to use the returned values (cookie, CSRF token) for subsequent authenticated requests.\nScripting We’ll develop our script in a Python module, independent of the specific SIEM we’re working with (Splunk). This way, the majority of the code can be tested outside of Splunk, and could be re-used without modification for any other SIEM.\nThe code below shows the login process - including the request, storing the resulting cookies through use of the Requests’ library’s Session object, and manually setting an X-Access-Token header value based on the value of csrf in the response to our authentication request:\ndef login(self): login_uri = \"/auth/user\" payload = { \"email\": self.username, \"password\": self.password, \"captchaKey\": \"null\", } # Login url = self.cloudinfra_gw_url + login_uri response = self.session.post(url=url, verify=False, json=payload) logger.info(f\"Status code from login: {response.status_code}\") if response.status_code != 200: return False else: self.csrf_token = response.json()[\"csrf\"] self.session.headers.update({\"X-Access-Token\": self.csrf_token}) return True The code below generates timestamps for our search window, submits a request and returns any matching records included in the response. Note that we’re using the same Session object from before so our requests include the cloudinfra cookie and X-Access-Token header required for authentication:\ndef query_active_attacks(self, hours_ago): threat_hunt_uri = \"/app/threathunting/prod-gcp-apollo/\" threat_dash_uri = \"/dashboard/endpoint/threathunting#/search\" # Prepare the query endpoint URL url = self.cloudinfra_gw_url + threat_hunt_uri current_time = ( datetime.now(timezone.utc) .isoformat(timespec=\"milliseconds\") .replace(\"+00:00\", \"Z\") ) earliest_time = ( (datetime.now(timezone.utc) - timedelta(hours=int(hours_ago))) .isoformat(timespec=\"milliseconds\") .replace(\"+00:00\", \"Z\") ) # Prepare query payload = cpharmony_consts.TH_ACTIVE_ATTACKS_PAYLOAD payload[\"variables\"][\"queryParam\"][\"dateRange\"][\"from\"] = earliest_time payload[\"variables\"][\"queryParam\"][\"dateRange\"][\"to\"] = current_time # Get detections payload_str = json.dumps(payload, separators=(\",\", \":\")) payload_str = payload_str.replace('\"null\"', \"null\") response = self.session.post(url=url, verify=False, data=payload_str) if response.status_code != 200: logger.error(response.text) return [] else: logger.debug(response.json()[\"data\"][\"searchRecords\"][\"metadata\"]) if response.json()[\"data\"][\"searchRecords\"][\"metadata\"][\"totalRows\"] \u003e 0: return response.json()[\"data\"][\"searchRecords\"][\"records\"] else: return [] return response.json() We’re not currently handling pagination; we’re instead working on the assumption that the alerts will be few enough - and poll period frequent enough - that we won’t exceed the default maximimum results of 50. We could also try increasing queryParam[\"Param\"][\"maxResults\"] for safety.\nFull code is available here: https://github.com/gf13579/ta_for_cpharmony.\nSIEM Integration We’ll place our authentication and query code in a cpharmony_connector class and call it from within a script used by Splunk for modular inputs:\n# ... cp_connector = cpharmony_connector( username=username, password=password, region=region, verify=True ) if not cp_connector.login(): logger.error(\"Failed to login\") return results = cp_connector.query_active_attacks(hours_ago=hours_ago) for r in results: event = Event() event.stanza = stanza event.data = json.dumps(r) ew.write_event(event) Finally, we can use the following Splunk-specific props.conf configuration settings to tell Splunk how to parse the timestamp from the raw JSON of each event:\n[checkpoint:harmony:json] KV_MODE=json TIME_FORMAT=%s%3N MAX_TIMESTAMP_LOOKAHEAD=13 TIME_PREFIX=OpTimeUTC\":\\s ... These settings help Splunk parse a millisecond-level epoch-based datetime value like \"OpTimeUTC\": 1669271153062\nThe focus of this post is on analysing and scripting the API used by a single page application - rather than developing a Splunk add-on. Notable resources are listed below, and the full add-on can be downloaded from GitHub or Splunkbase (pending).\nFeature Purpose Link Simple setup page Handle password.conf updates with minimal code setup_page_simple (Splunk on GitHub) splunk-sdk-python random_numbers example Simple modular input example random_numbers (Splunk on GitHub) Loguru Python logging made simple loguru (GitHub) Splunk Configuration Once installed, the add-on should be setup with a password using the simple setup page:\nThen create a new Data Input:\nSIEM Alerts Since we’re using a time-based poll approach with no checkpointing, our scheduled query may well end up ingesting duplicate events. We could enhance our add-on to maintain state, but for now we’ll just dedupe events at search time.\nWhen we build our detection for Splunk ES we’ll dedupe based on DetectionEvent.DetectionIncidentId and use props.conf to normalise the field names a little to comply as best as possible with Splunk’s Common Information Model (CIM), ensuring that\nThe most relevant fields are exposed to the analyst; Splunk-authored detections can operate over the event data with minimal changes; Asset and identity correlation is performed automatically When the detection fires we see our Check Point-generated alerts exposed in the SIEM - exposing key fields to the analyst, enriched with user and endpoint inventory information, and impacting risk scores on the asset and identities involved in the detection:\nWrapping Up We overcame a frustrating lack of integration support in a vendor product by scripting the process used by an interactive user. The API-based architecture of the vendor’s web application greatly simplified the task, and meant we could do most of the analysis and scripting using standard browser dev tools and a very small amount of Python.\nOne final point to note - we’re using an undocumented API that’s intended for Check Point’s own web application; so there’s a chance the API will change and our code will break. However, this is true even of documented and supported APIs - and one of many reasons to monitor the health of SIEM log sources. Hopefully Check Point will introduce support for API-based alert integration in the near future.\n","wordCount":"1443","inLanguage":"en","datePublished":"2022-12-02T00:49:16+10:00","dateModified":"2022-12-02T00:49:16+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://spinningplates.net/posts/borrowing-apis-from-single-page-apps/"},"publisher":{"@type":"Organization","name":"spinning plates","logo":{"@type":"ImageObject","url":"https://spinningplates.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://spinningplates.net/ accesskey=h title="spinning plates (Alt + H)">spinning plates</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Connecting the Unconnectable; Borrowing APIs from Single Page Applications</h1><div class=post-meta><span title='2022-12-02 00:49:16 +1000 +1000'>December 2, 2022</span></div></header><div class=post-content><p>A SIEM typically collects event data, runs detections, generates alerts and serves as a single pane of glass for security alerts. One of the fundamental types of event to ingest is malware alerts from endpoint antivirus and EDR solutions. Malware alerts may seem dull - no user behaviour analytics, no machine learning, but we very often read incident response reports where an attacker triggered AV/EDR alerts that were completely ignored, before eventually executing a ransomware attack or exfiltrating data.</p><p>Some products make this easy - cloud-managed solutions might provide an API to poll for new alerts, on-prem products might write events to an event log or log file. Others might let you configure them to send an email or contact a webhook to notify you about a detection.</p><p>Some products make this much harder than it should be. In this post we&rsquo;ll look at Check Point Harmony (CPH), which presents the following challenges:</p><ol><li>An API that doesn&rsquo;t currently support polling for EDR detections</li><li>Email notifications that can&rsquo;t be used to alert on every detection as they have thresholds that can&rsquo;t be set lower than 2</li><li>A syslog-over-the-internet approach, recommended by Check Point, but apparently not relevant if an organisation has no on-prem management servers</li></ol><h2 id=the-query-process>The Query Process<a hidden class=anchor aria-hidden=true href=#the-query-process>#</a></h2><p>What CPH <em>does</em> let you do is view detections (&lsquo;active attacks&rsquo;) through its Infinity Portal web site - here we see the Threat Hunting tab list 2 &lsquo;active attacks&rsquo; i.e. open alerts based on detections:</p><p><a href=Pastedimage20221125090248.png><img loading=lazy src=Pastedimage20221125090248.png alt></a></p><p>Drilling down on those 2 alerts:</p><p><a href=Pastedimage20221125090622.png><img loading=lazy src=Pastedimage20221125090622.png alt></a></p><p>Modern websites commonly use a <a href=https://en.wikipedia.org/wiki/Single-page_application>Single Page Application</a> approach where client-side JavaScript code is used to access backend APIs as a user interacts with the web application, avoiding the need for full page refreshes and (usually) resulting in better interactive experience for the user.</p><p>If we hit F12 to open the browser&rsquo;s dev tools, open the Network tab and refresh the page, we can watch for Fetch/XmlHttpRequest requests made when the page loads. Searching all content for a distinctive value shown on the web page (e.g. <code>nvio.x64.exe</code>) we see a response from <code>prod-gcp-apollo/</code> that returns JSON data containing full details of the detection - to be rendered client-side:</p><p><a href=Pastedimage20221128203349.png><img loading=lazy src=Pastedimage20221128203349.png alt></a></p><p>The payload in the request that generated this content shows that a query string was submitted, along with parameters controlling date ranges, result order and pagination:</p><p><a href=Pastedimage20221128204710.png><img loading=lazy src=Pastedimage20221128204710.png alt></a></p><p>So now we know we know which endpoint (<code>prod-gcp-apollo/</code>) to query, the method (POST), the body of the request, and what the response looks like.</p><p>All that remains is to analyse the authentication process, then recreate the two steps (authenticate, query) in a scheduled script that outputs the results to our SIEM.</p><h2 id=authentication>Authentication<a hidden class=anchor aria-hidden=true href=#authentication>#</a></h2><p>Let&rsquo;s apply the same process to analyse authentication. Check Point provides options to manage API keys, however, the API doesn&rsquo;t yet support what we&rsquo;re trying to query. We&rsquo;ll need to use a user account acting as a service account (ideally with least privileges and a complex password).</p><p>When we browse to <a href=https://ap.portal.checkpoint.com/signin>https://ap.portal.checkpoint.com/signin</a> we&rsquo;re prompted for a username, then a password. The Network tab shows a POST against <code>/auth/user</code>:</p><p><a href=Pastedimage20221128210153.png><img loading=lazy src=Pastedimage20221128210153.png alt></a></p><p>We can see the server response included a directive to set a <code>cloudinfra</code> cookie - a signed <a href=https://en.wikipedia.org/wiki/JSON_Web_Token>JWT</a> - containing assertions about our identity and permissions:</p><p><a href=Pastedimage20221128210403.png><img loading=lazy src=Pastedimage20221128210403.png alt></a></p><p>In addition, towards the end of the response we see a value called <code>csrf</code> - a Cross Site Request Forgery (<a href=https://en.wikipedia.org/wiki/Cross-site_request_forgery>CSRF</a>) token with an expiry of 900 seconds (15 minutes):</p><p><a href=Pastedimage20221128211613.png><img loading=lazy src=Pastedimage20221128211613.png alt></a></p><p>The browser will automatically include our cookie in subsequent requests to the same origin (<a href=https://ap.portal.checkpoint.com>https://ap.portal.checkpoint.com</a>). It&rsquo;s likely the server will also expect the CSRF token to be included and will validate that the token corresponds to our session - and potentially the code submitting the request.</p><p>Looking at subsequent requests - including the one to retrieve active attacks, we see the same CSRF token appear as a custom HTTP header in the request:</p><p><a href=Pastedimage20221128211730.png><img loading=lazy src=Pastedimage20221128211730.png alt></a></p><p>We now know how to authenticate with a username and password, and how to use the returned values (cookie, CSRF token) for subsequent authenticated requests.</p><h2 id=scripting>Scripting<a hidden class=anchor aria-hidden=true href=#scripting>#</a></h2><p>We&rsquo;ll develop our script in a Python module, independent of the specific SIEM we&rsquo;re working with (Splunk). This way, the majority of the code can be tested outside of Splunk, and could be re-used without modification for any other SIEM.</p><p>The code below shows the login process - including the request, storing the resulting cookies through use of the Requests&rsquo; library&rsquo;s Session object, and manually setting an X-Access-Token header value based on the value of <code>csrf</code> in the response to our authentication request:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>login</span>(self):
</span></span><span style=display:flex><span>	login_uri <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/auth/user&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	payload <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;email&#34;</span>: self<span style=color:#f92672>.</span>username,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;password&#34;</span>: self<span style=color:#f92672>.</span>password,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;captchaKey&#34;</span>: <span style=color:#e6db74>&#34;null&#34;</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Login</span>
</span></span><span style=display:flex><span>	url <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>cloudinfra_gw_url <span style=color:#f92672>+</span> login_uri
</span></span><span style=display:flex><span>	response <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>post(url<span style=color:#f92672>=</span>url, verify<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, json<span style=color:#f92672>=</span>payload)
</span></span><span style=display:flex><span>	logger<span style=color:#f92672>.</span>info(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Status code from login: </span><span style=color:#e6db74>{</span>response<span style=color:#f92672>.</span>status_code<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>!=</span> <span style=color:#ae81ff>200</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>csrf_token <span style=color:#f92672>=</span> response<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#34;csrf&#34;</span>]
</span></span><span style=display:flex><span>		self<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>headers<span style=color:#f92672>.</span>update({<span style=color:#e6db74>&#34;X-Access-Token&#34;</span>: self<span style=color:#f92672>.</span>csrf_token})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p>The code below generates timestamps for our search window, submits a request and returns any matching records included in the response. Note that we&rsquo;re using the same Session object from before so our requests include the <code>cloudinfra</code> cookie and X-Access-Token header required for authentication:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>query_active_attacks</span>(self, hours_ago):
</span></span><span style=display:flex><span>	threat_hunt_uri <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/app/threathunting/prod-gcp-apollo/&#34;</span>
</span></span><span style=display:flex><span>	threat_dash_uri <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/dashboard/endpoint/threathunting#/search&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Prepare the query endpoint URL</span>
</span></span><span style=display:flex><span>	url <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>cloudinfra_gw_url <span style=color:#f92672>+</span> threat_hunt_uri
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	current_time <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>		datetime<span style=color:#f92672>.</span>now(timezone<span style=color:#f92672>.</span>utc)
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span>isoformat(timespec<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;milliseconds&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;+00:00&#34;</span>, <span style=color:#e6db74>&#34;Z&#34;</span>)
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	earliest_time <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>		(datetime<span style=color:#f92672>.</span>now(timezone<span style=color:#f92672>.</span>utc) <span style=color:#f92672>-</span> timedelta(hours<span style=color:#f92672>=</span>int(hours_ago)))
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span>isoformat(timespec<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;milliseconds&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#34;+00:00&#34;</span>, <span style=color:#e6db74>&#34;Z&#34;</span>)
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Prepare query</span>
</span></span><span style=display:flex><span>	payload <span style=color:#f92672>=</span> cpharmony_consts<span style=color:#f92672>.</span>TH_ACTIVE_ATTACKS_PAYLOAD
</span></span><span style=display:flex><span>	payload[<span style=color:#e6db74>&#34;variables&#34;</span>][<span style=color:#e6db74>&#34;queryParam&#34;</span>][<span style=color:#e6db74>&#34;dateRange&#34;</span>][<span style=color:#e6db74>&#34;from&#34;</span>] <span style=color:#f92672>=</span> earliest_time
</span></span><span style=display:flex><span>	payload[<span style=color:#e6db74>&#34;variables&#34;</span>][<span style=color:#e6db74>&#34;queryParam&#34;</span>][<span style=color:#e6db74>&#34;dateRange&#34;</span>][<span style=color:#e6db74>&#34;to&#34;</span>] <span style=color:#f92672>=</span> current_time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e># Get detections</span>
</span></span><span style=display:flex><span>	payload_str <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>dumps(payload, separators<span style=color:#f92672>=</span>(<span style=color:#e6db74>&#34;,&#34;</span>, <span style=color:#e6db74>&#34;:&#34;</span>))
</span></span><span style=display:flex><span>	payload_str <span style=color:#f92672>=</span> payload_str<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39;&#34;null&#34;&#39;</span>, <span style=color:#e6db74>&#34;null&#34;</span>)
</span></span><span style=display:flex><span>	response <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>post(url<span style=color:#f92672>=</span>url, verify<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, data<span style=color:#f92672>=</span>payload_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>status_code <span style=color:#f92672>!=</span> <span style=color:#ae81ff>200</span>:
</span></span><span style=display:flex><span>		logger<span style=color:#f92672>.</span>error(response<span style=color:#f92672>.</span>text)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		logger<span style=color:#f92672>.</span>debug(response<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#34;data&#34;</span>][<span style=color:#e6db74>&#34;searchRecords&#34;</span>][<span style=color:#e6db74>&#34;metadata&#34;</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> response<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#34;data&#34;</span>][<span style=color:#e6db74>&#34;searchRecords&#34;</span>][<span style=color:#e6db74>&#34;metadata&#34;</span>][<span style=color:#e6db74>&#34;totalRows&#34;</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()[<span style=color:#e6db74>&#34;data&#34;</span>][<span style=color:#e6db74>&#34;searchRecords&#34;</span>][<span style=color:#e6db74>&#34;records&#34;</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> []
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> response<span style=color:#f92672>.</span>json()
</span></span></code></pre></div><p>We&rsquo;re not currently handling pagination; we&rsquo;re instead working on the assumption that the alerts will be few enough - and poll period frequent enough - that we won&rsquo;t exceed the default maximimum results of 50. We could also try increasing <code>queryParam["Param"]["maxResults"]</code> for safety.</p><p>Full code is available here: <a href=https://github.com/gf13579/ta_for_cpharmony>https://github.com/gf13579/ta_for_cpharmony</a>.</p><h2 id=siem-integration>SIEM Integration<a hidden class=anchor aria-hidden=true href=#siem-integration>#</a></h2><p>We&rsquo;ll place our authentication and query code in a <code>cpharmony_connector</code> class and call it from within a script used by Splunk for modular inputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>cp_connector <span style=color:#f92672>=</span> cpharmony_connector(
</span></span><span style=display:flex><span>	username<span style=color:#f92672>=</span>username, password<span style=color:#f92672>=</span>password, region<span style=color:#f92672>=</span>region, verify<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> cp_connector<span style=color:#f92672>.</span>login():
</span></span><span style=display:flex><span>	logger<span style=color:#f92672>.</span>error(<span style=color:#e6db74>&#34;Failed to login&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>results <span style=color:#f92672>=</span> cp_connector<span style=color:#f92672>.</span>query_active_attacks(hours_ago<span style=color:#f92672>=</span>hours_ago)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> r <span style=color:#f92672>in</span> results:
</span></span><span style=display:flex><span>	event <span style=color:#f92672>=</span> Event()
</span></span><span style=display:flex><span>	event<span style=color:#f92672>.</span>stanza <span style=color:#f92672>=</span> stanza
</span></span><span style=display:flex><span>	event<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>dumps(r)
</span></span><span style=display:flex><span>	ew<span style=color:#f92672>.</span>write_event(event)
</span></span></code></pre></div><p>Finally, we can use the following Splunk-specific <code>props.conf</code> configuration settings to tell Splunk how to parse the timestamp from the raw JSON of each event:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>checkpoint</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#a6e22e>harmony</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#a6e22e>json</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>KV_MODE</span>=<span style=color:#a6e22e>json</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TIME_FORMAT</span>=<span style=color:#960050;background-color:#1e0010>%</span><span style=color:#a6e22e>s</span><span style=color:#960050;background-color:#1e0010>%</span><span style=color:#ae81ff>3</span><span style=color:#a6e22e>N</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>MAX_TIMESTAMP_LOOKAHEAD</span>=<span style=color:#ae81ff>13</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TIME_PREFIX</span>=<span style=color:#a6e22e>OpTimeUTC</span><span style=color:#960050;background-color:#1e0010>&#34;:\</span><span style=color:#a6e22e>s</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>These settings help Splunk parse a millisecond-level epoch-based datetime value like <code>"OpTimeUTC": 1669271153062</code></p><p>The focus of this post is on analysing and scripting the API used by a single page application - rather than developing a Splunk add-on. Notable resources are listed below, and the full add-on can be downloaded from <a href=https://github.com/gf13579/ta_for_cpharmony>GitHub</a> or <a href=https://splunkbase.splunk.com/app/6692>Splunkbase</a> (pending).</p><table><thead><tr><th>Feature</th><th>Purpose</th><th>Link</th><th></th></tr></thead><tbody><tr><td>Simple setup page</td><td>Handle password.conf updates with minimal code</td><td><a href=https://github.com/splunk/splunk-app-examples/tree/master/setup_pages/setup_page_simple>setup_page_simple (Splunk on GitHub)</a></td><td></td></tr><tr><td>splunk-sdk-python random_numbers example</td><td>Simple modular input example</td><td><a href=https://github.com/splunk/splunk-app-examples/tree/master/modularinputs/python/random_numbers>random_numbers (Splunk on GitHub)</a></td><td></td></tr><tr><td>Loguru</td><td>Python logging made simple</td><td><a href=https://github.com/Delgan/loguru>loguru (GitHub)</a></td><td></td></tr></tbody></table><h2 id=splunk-configuration>Splunk Configuration<a hidden class=anchor aria-hidden=true href=#splunk-configuration>#</a></h2><p>Once installed, the add-on should be setup with a password using the simple setup page:</p><p><a href=Pastedimage20221128220620.png><img loading=lazy src=Pastedimage20221128220620.png alt></a></p><p>Then create a new Data Input:</p><p><a href=Pastedimage20221128221139.png><img loading=lazy src=Pastedimage20221128221139.png alt></a></p><h2 id=siem-alerts>SIEM Alerts<a hidden class=anchor aria-hidden=true href=#siem-alerts>#</a></h2><p>Since we&rsquo;re using a time-based poll approach with no checkpointing, our scheduled query may well end up ingesting duplicate events. We could enhance our add-on to maintain state, but for now we&rsquo;ll just dedupe events at search time.</p><p>When we build our detection for Splunk ES we&rsquo;ll dedupe based on <code>DetectionEvent.DetectionIncidentId</code> and use <code>props.conf</code> to normalise the field names a little to comply as best as possible with Splunk&rsquo;s Common Information Model (CIM), ensuring that</p><ul><li>The most relevant fields are exposed to the analyst;</li><li>Splunk-authored detections can operate over the event data with minimal changes;</li><li>Asset and identity correlation is performed automatically</li></ul><p>When the detection fires we see our Check Point-generated alerts exposed in the SIEM - exposing key fields to the analyst, enriched with user and endpoint inventory information, and impacting risk scores on the asset and identities involved in the detection:</p><p><a href=Pastedimage20221125090742.png><img loading=lazy src=Pastedimage20221125090742.png alt></a></p><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>We overcame a frustrating lack of integration support in a vendor product by scripting the process used by an interactive user. The API-based architecture of the vendor&rsquo;s web application greatly simplified the task, and meant we could do most of the analysis and scripting using standard browser dev tools and a very small amount of Python.</p><p>One final point to note - we&rsquo;re using an undocumented API that&rsquo;s intended for Check Point&rsquo;s own web application; so there&rsquo;s a chance the API will change and our code will break. However, this is true even of documented and supported APIs - and one of many reasons to monitor the health of SIEM log sources. Hopefully Check Point will introduce support for API-based alert integration in the near future.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2022 <a href=https://spinningplates.net/>Greg Ford.</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>